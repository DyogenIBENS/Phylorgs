#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""Various indices of tree imbalance.

See:

* [Blum & François 2005,
On statistical tests of phylogenetic tree imbalance:
The Sackin and other indices revisited](http://membres-timc.imag.fr/Olivier.Francois/sackin.pdf)

* Sackin 1972, "Good" and "bad" phenograms
* Shao and Sokal 1990, Tree balance
* Colless 1982, Review of Phylogenetics: the theory and practice of phylogenetic systematics
* Mir et al. 2013, A new balance index for phylogenetic trees
"""

from collections import defaultdict
from itertools import product
from random import randrange, sample
from queue import deque
from math import factorial
import numpy as np
from scipy.special import binom
from LibsDyogen import myTools
import logging
logger = logging.getLogger(__name__)


def sackin(tree):
    return sum(len(l.get_ancestors()) for l in tree.iter_leaves())

# Alternative mathematical formula, just to check it works.
def sackin_bis(tree):
    return sum(len(n) for n in tree.traverse() if not n.is_leaf())


def expectation_sackin(N):
    """For a dichotomic tree generated by the Yule model."""
    return 2. * N * sum(1./j for j in range(2, N+1))

def normed_sackin(tree):
    # Beware. This is not a proper normalisation, as the standard deviation
    # of the Sackin index doesn't really depend on `n`
    n = len(tree)
    return (sackin(tree) - expectation_sackin(tree)) / float(n)


@myTools.memoize
def sackin_minmax(n, n_poly=0):
    """For dichotomic trees.
    The maximum imbalance is for a caterpillar tree.
    The minimum is for successive splits of similar sizes.
    """
    sackin_maximum = sum(range(1,n)) + n-1  # easy: caterpillar tree:
    # Unsure if the caterpillar logic applies to the max with polytomies
    for i in range(1, n_poly+1):
        sackin_maximum -= (i+1)  # Collapse the furthest fork. the first polytomy removes a cherry, i.e. 2 in the sackin index.

    sackin_minimum = 0
    nextnodes = deque([(1, n)])  # (dist to the root, number of leaves)
    # 1 polytomy at the root might be the best. But not necessarily for 2 polytomies
    # Would have been more logical to proceed by grouping the leaves level by level.
    while nextnodes:
        dist2root, nleaves = nextnodes.popleft()
        if nleaves > 1:
            sackin_minimum += nleaves
            half_n = nleaves // 2
            nextnodes.extend(((dist2root+1, half_n),
                              (dist2root+1, half_n + nleaves%2)))

    return sackin_minimum, sackin_maximum


@myTools.memoize
def sackin_distribs(N):
    """
    N: number of leaves of the tree

    Return the list of N distribs (for the trees from 1 to N leaves).
    Each "distribution" contains the number of ways to obtain each Sackin index.
    Each possible **leaf-labelled** topology counts as 1 way.
    
    For example, for the caterpillar topology with N leaves, there are N!/2
    leaf-labelling (division by 2 because the single cherry can rotate).
    
    Recurse from the small trees to larger trees:
    for each level up (tree of size n), use the following recursion:
    
        Sn = S(j) + S(n-j) + n.
    
    for each possible j (from 1 to n//2 + 1).

    Note: n_poly=2 can be interpreted as 2 trifurcations or 1 quadrifurcation
    """
    minmax = [sackin_minmax(1)]
    distribs = [defaultdict(int)]
    distribs[0][0] = 1  # Only 1 way to make a tree of one node (sackin value of zero) 
    for n in range(2, N+1-n_poly):
        m,M = sackin_minmax(n)
        logger.debug('# subtree of size %d; minmax=[%d, %d]', n, m, M)
        minmax.append((m,M))
        distrib = defaultdict(int)
        distrib[M] = factorial(n) // 2  # Caterpillar tree. The single cherry can rotate.

        # For each left subtree of size k
        # if n is even: go up to n/2 (included)
        # if n is odd: go up to (n-1)/2 (included)
        for k in range(1, n//2 + 1):
            # Fetch the minmax values of the two subtrees of sizes k, n-k.
            mk, Mk = minmax[k - 1]  # -1 because indexing of minmax starts at 0
            mn_k, Mn_k = minmax[n-k - 1]  # m(n-k), M(n-k)

            # Number of ways to put n leaves in 2 groups of sizes (k, n-k)
            ck = binom(n,k)  # Warning: the binom function may return a float approximation.
            if n%2 == 0 and k == n//2:
                # 2 splits are identical by rotation of the 2 subtrees.
                ck /= 2
            logger.debug('  - split k=%d: %g way(s)', k, ck)
            # For each possible value of the Sackin index of the tree of size n
            for v in range(m, M):
                # All possible ways to split the value between the 2 subtrees
                # Remember the recursive relation:
                pk = 0
                # Contraints:
                # 1)  mk         ≤ vk     ≤ Mk
                # 2)  mn_k       ≤ v-n-vk ≤ Mn_k
                #     v-n - Mn_k ≤     vk ≤ v-n - mn_k
                for vk in range(max(0, mk, v-n - Mn_k), min(v, Mk, v-n - mn_k) + 1):
                #for vk in range(max(1, mk), min(v, Mk) + 1):
                #for vk in range(1, v-n):
                    logger.debug('    value(n) = %d = n + value(k) + value(n-k) = %d + %d + %d',
                                 v, n, vk, v-n-vk)
                    logger.debug('    ways += %d × %d', distribs[k - 1][vk],
                                 distribs[n-k - 1][v-n - vk])
                    pk += distribs[k - 1][vk] * distribs[n-k - 1][v-n - vk]

                distrib[v] += ck*pk

        distribs.append(distrib)
    return distribs  # distrib


@myTools.memoize
def sackin_distribs_poly(N, n_poly=0):
    """
    Note: n_poly=2 can be interpreted as 2 trifurcations or 1 quadrifurcation
    """
    minmax = [[sackin_minmax(1, n_poly=i) for i in range(n_poly+1)]]
    distribs = [defaultdict(int)]
    distribs[0][0] = 1  # Only 1 way to make a tree of one node (sackin value of zero) 
    for n in range(2, N+1-n_poly):
        m,M = sackin_minmax(n)
        logger.debug('# subtree of size %d; minmax=[%d, %d]', n, m, M)
        minmax.append((m,M))
        distrib = defaultdict(int)
        if n not in loc_poly:
            distrib[M] = factorial(n) // 2  # Caterpillar tree. The single cherry can rotate.

            # For each left subtree of size k
            # if n is even: go up to n/2 (included)
            # if n is odd: go up to (n-1)/2 (included)
            for k in range(1, n//2 + 1):
                # Fetch the minmax values of the two subtrees of sizes k, n-k.
                mk, Mk = minmax[k - 1]  # -1 because indexing of minmax starts at 0
                mn_k, Mn_k = minmax[n-k - 1]  # m(n-k), M(n-k)

                # Number of ways to put n leaves in 2 groups of sizes (k, n-k)
                ck = binom(n,k)  # Warning: the binom function may return a float approximation.
                if n%2 == 0 and k == n//2:
                    # 2 splits are identical by rotation of the 2 subtrees.
                    ck /= 2
                logger.debug('  - split k=%d: %g way(s)', k, ck)
                # For each possible value of the Sackin index of the tree of size n
                for v in range(m, M):
                    # All possible ways to split the value between the 2 subtrees
                    # Remember the recursive relation:
                    pk = 0
                    # Contraints:
                    # 1)  mk         ≤ vk     ≤ Mk
                    # 2)  mn_k       ≤ v-n-vk ≤ Mn_k
                    #     v-n - Mn_k ≤     vk ≤ v-n - mn_k
                    for vk in range(max(0, mk, v-n - Mn_k), min(v, Mk, v-n - mn_k) + 1):
                    #for vk in range(max(1, mk), min(v, Mk) + 1):
                    #for vk in range(1, v-n):
                        logger.debug('    value(n) = %d = n + value(k) + value(n-k) = %d + %d + %d',
                                     v, n, vk, v-n-vk)
                        logger.debug('    ways += %d × %d', distribs[k - 1][vk],
                                     distribs[n-k - 1][v-n - vk])
                        pk += distribs[k - 1][vk] * distribs[n-k - 1][v-n - vk]

                    distrib[v] += ck*pk

        distribs.append(distrib)
    return distribs  # distrib

@myTools.memoize
def sackin_distribs_yule(N, n_poly=0):
    """
    N: number of leaves of the tree

    Return the list of N distribs (for the trees from 1 to N leaves).
    Each "distribution" contains the number of ways to obtain each Sackin index,
    under the Yule branching process:
    - each extant node has the same proba to split.
    - equivalently, each pair of adjacent nodes has the same proba to coalesce.
    
    We have to consider leaf labels as ordered.

    Recurse from the small trees to larger trees:
    for each level up (tree of size n), use the following recursion:
    
        Sn = S(j) + S(n-j) + n.
    
    for each possible j (from 1 to n//2 + 1).
    """
    minmax = {1: sackin_minmax(1), 2: sackin_minmax(2)}
    # X[n][k] : number of ways to obtain Sackin(n) == k
    X = {1: defaultdict(int), 2: defaultdict(int)}
    X[1][0] = 1  # Only 1 way to make a tree of one node (sackin value of zero) 
    X[2][2] = 1  # only one yule tree of size 2.
    # Iterate over coalescence events from the present (grouping 2 leaves), to the root (coalescing all N leaves).
    for n in range(3, N+1):
        m,M = minmax[n] = sackin_minmax(n)
        logger.debug('# subtree of size %d; minmax=[%d, %d]', n, m, M)
        X[n] = Xn = defaultdict(int)

        # All possible sizes of 2 subtrees in the group of size n:
        # For each left subtree of size i
        # if n is even: go up to n/2 (included)
        # if n is odd: go up to (n-1)/2 (included)
        #for i in range(1, n//2 + 1):
        for i in range(1, n):
            # Fetch the minmax values of the two subtrees of sizes i, n-i.
            mi, Mi = minmax[i]
            mn_i, Mn_i = minmax[n-i]  # m(n-i), M(n-i)

            # Multiply by the number of orderings of the branchings in the two subtrees.
            # (because Yule makes each split one by one, so the order matters.
            c_i = int(binom(n-2, i-1))  # How to place i-1 nodes in a serie of n-2 nodes.
            #if n%2 == 0 and i < n//2:
            #    c_i *= 2
            logger.debug('  - split i=%d, c_i=%s', i, c_i)
            
            # For each possible pair of Sackin values of both subtrees of sizes i, n-i
            for s1,s2 in product(range(mi, Mi+1), range(mn_i, Mn_i+1)):
                logger.debug('      Fill %d = n + %d + %d  -> c_i * %s * %s', n+s1+s2, s1, s2, X[i][s1], X[n-i][s2])
                Xn[n+s1+s2] += c_i * X[i][s1] * X[n-i][s2]
        assert Xn[M] == 2**(n-2)  # Number scenarios producing caterpillar topologies under Yule.

    return X  # distrib

def counts_to_freqs(d):
    tot = float(sum(c for c in d.values()))
    values = []
    freqs = []
    for k,c in sorted(d.items(), key=lambda item: item[0]):
        values.append(k)
        freqs.append(c/tot)
    return np.array(values), np.array(freqs)


def simyul(N, tn=1000):
    """Simulate tn Yule trees of N leaves (forward time)"""


def simyul_sackin(N, tn=1000):
    S = np.zeros(tn, dtype=int)
    for t in range(tn):
        leaf_n_ancs = [0]  # number of ancestral nodes before leaf
        # Run the Yule process, i.e. perform N-1 branchings
        for n in range(1, N):
            b = randrange(0, n)  # Which node is branching?
            ancs_b = leaf_n_ancs[b]
            leaf_n_ancs = leaf_n_ancs[:b] + [ancs_b+1]*2  + leaf_n_ancs[(b+1):]
        S[t] = sum(leaf_n_ancs)
    return S


def simtopo_sackin(N, tn=1000, n_poly=0):
    # rooted, unlabelled
    S = np.zeros(tn, dtype=int)
    for t in range(tn):
        loc_poly = np.random.choice(N-n_poly, n_poly)
        # recursively split the set of leaves
        lims = [N]
        leaf_n_ancs = np.zeros(N, dtype=int)
        n_splits = 0
        while n_splits < N-1-n_poly:
            prev_lim = 0
            for i, lim in enumerate(list(lims)):
                n_new_lims = 1 + (loc_poly==n_splits+1).sum()
                if lim - prev_lim >= n_new_lims:
                    new_lims = sample(range(prev_lim, lim), n_new_lims)
                    lims += new_lims
                    n_splits += 1
                    leaf_n_ancs[prev_lim:lim] += 1
                prev_lim = lim
            lims.sort()
        S[t] = leaf_n_ancs.sum()
    return S


def simlabtopo_sackin():
    pass


def test_sackin_minmax():
    assert sackin_minmax(1) == (0,0)
    assert sackin_minmax(2) == (2,2)
    assert sackin_minmax(3) == (5,5)
    assert sackin_minmax(4) == (8,9)
    assert sackin_minmax(5) == (12, 14)
    assert sackin_minmax(6) == (16, 20)
    #assert sackin_minmax(7)

# From Felsenstein, _Inferring Phylogenies_ (Sinauer and associates), Ch.3
n_rooted_labelled_topo = {1:1, 2:1, 3:3, 4:15, 5:105, 6:945, 7:10395,
        8:135135, 9:2027025, 10:34459425, 11:654729075, 12:13749310575,
        13:316234143225, 14:7905853580625, 15:213458046676875,
        16:6190283353629375, 17:191898783962510625, 18:6332659870762850625,
        19:221643095476699771875, 20:8200794532637891559375}


def test_sackin_distrib():

    # The sum of p should equal the number of possible labelled topologies
    d1, d2, d3, d4, d5, d6 = sackin_distrib(6)

    assert sum(d1.values()) == 1
    assert d1[0] == 1

    assert sum(d2.values()) == 1
    assert d2[2] == 1

    assert sum(d3.values()) == 3
    assert d3[5] == 3

    assert sum(d4.values()) == 3 + 4*3*2//2  # Balanced (4 choose 2)/2 + Caterpillar
    assert d4[8] == 3
    assert d4[9] == 12

    assert sum(d5.values()) == 105
    assert d5[14] == 60
    assert d5[12] == 30
    assert d5[13] == 15

    assert sum(d6.values()) == n_rooted_labelled_topo[6]  # 945
    assert d6[16] == 90+45  # 2 corresponding topologies
    assert d6[17] == 180
    assert d6[18] == 180
    assert d6[19] == 90
    assert d6[20] == factorial(6)/2  # 360


def n_cherries(tree):
    return len([n for n in tree.traverse() if all(ch.is_leaf() for ch in n.children)])


def colless(tree):
    s = 0
    for n in tree.traverse():
        children = n.children
        if len(children) < 2:
            continue
        elif len(children) > 2:
            #FIXME
            raise ValueError("Tree should be dichotomic")
        ch0, ch1 = children
        s += abs(len(ch0) - len(ch1))


def normed_colless(tree):
    """Equals 1 for a caterpillar tree"""
    n = len(tree)
    return colless(tree) * 2. / ((n-1)*(n-2))


def mir(tree):
    """Mir et al 2013: Sum, for all pairs of leaves, of the depth of the
    lowest common ancestor."""
    pass
